# Cubic Hermite Spline Trajectory Planner for RRT* Waypoints

## Overview

This implementation provides a Cubic Hermite Spline trajectory planner specifically designed to work with waypoints generated by RRT* (RRT-star) path planning algorithms. This approach was used by top SSL teams during 2010-2015, particularly ZJUNlict (RoboCup 2013 champions) and CMDragons.

## Background

### The Problem
RRT* generates waypoints that are:
- Collision-free but not smooth
- Connected by straight line segments
- May have sharp turns at waypoints
- Not directly suitable for robot trajectory execution

### The Solution
Cubic Hermite Splines provide:
- C1 continuity (continuous position and velocity)
- Smooth transitions through waypoints
- Natural velocity profiles
- Efficient computation

## Implementation Details

### Key Components

1. **CubicHermiteSplineTrajectory** (`ctrl/src/CubicHermiteSplineTrajectory.cpp`)
   - Core trajectory planning using cubic Hermite polynomials
   - Handles waypoint interpolation with tangent computation
   - Provides velocity commands for trajectory tracking

2. **HermiteSplineTrajectoryManager** (`ctrl/src/HermiteSplineTrajectoryManager.cpp`)
   - Wrapper that integrates with RobotManager
   - Manages trajectory execution and safety limits
   - Provides feedback control for trajectory tracking

### Mathematical Foundation

#### Cubic Hermite Polynomial
For each segment between waypoints, the position is defined as:
```
p(t) = c0 + c1*t + c2*t² + c3*t³
```

Where coefficients are computed from:
- p0: Start position
- p1: End position  
- m0: Start tangent (velocity)
- m1: End tangent (velocity)

#### Tangent Computation
Tangents at waypoints are computed using Catmull-Rom method:
- Interior points: Weighted average of neighboring segments
- Endpoints: Forward/backward differences

### Key Features

1. **Smooth Trajectory Generation**
   - Automatically computes tangents for smooth curves
   - Maintains velocity continuity at waypoints
   - Handles angular normalization for orientation

2. **Real-time Performance**
   - Pre-computes polynomial coefficients
   - Efficient evaluation during execution
   - Suitable for 60Hz control loops

3. **Feedback Control**
   - PD controller for trajectory tracking
   - Position error compensation
   - Velocity limiting for safety

## Usage

### Basic Usage
```cpp
// Create robot manager
rob::RobotManager robot_manager;

// RRT* waypoints (example)
std::vector<Eigen::Vector3d> waypoints = {
    Eigen::Vector3d(0.0, 0.0, 0.0),
    Eigen::Vector3d(0.5, 0.2, 0.3),
    Eigen::Vector3d(1.0, 0.5, 0.8),
    Eigen::Vector3d(1.5, 1.0, 1.2)
};

// Set Hermite Spline path
robot_manager.SetHermiteSplinePath(waypoints);
```

### Parameters
- `v_max`: Maximum linear velocity (default: 2.0 m/s)
- `omega_max`: Maximum angular velocity (default: 5.0 rad/s)
- `kp`: Proportional gain for tracking (default: 2.0)
- `kd`: Derivative gain for tracking (default: 0.5)

## Advantages for RRT* Integration

1. **Waypoint Handling**: Naturally handles discrete waypoints from RRT*
2. **Smoothness**: Generates smooth trajectories through waypoints
3. **Flexibility**: Works with any number of waypoints
4. **Robustness**: Handles sharp turns and direction changes

## Testing

Run the demo program:
```bash
./demo_hermite_spline_trajectory
```

This tests various waypoint configurations including:
- Straight line paths
- L-shaped paths
- Complex multi-turn paths
- Sharp 90-degree turns

## Historical Context

This approach was successfully used by:
- **ZJUNlict**: Combined with Dynamic Movement Primitives (DMPs)
- **CMDragons**: Part of their STP (Skills, Tactics, Plays) framework
- Both teams noted improved performance over direct waypoint following

## Future Enhancements

1. **Velocity Constraints**: Add per-waypoint velocity constraints
2. **Time Optimization**: Optimize segment durations for minimum time
3. **Obstacle Avoidance**: Dynamic replanning capability
4. **Multi-robot Coordination**: Synchronized trajectories for passing