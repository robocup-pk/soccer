#!/usr/bin/env python3
"""
Spline2D Verification Script
Reads the log file generated by Spline2D class and verifies:
1. Spline smoothness and continuity
2. Velocity profile constraints
3. Acceleration limits
4. Curvature calculations
5. Arc length consistency
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple
import argparse
import os


class SplineVerifier:
    def __init__(self, log_filename: str):
        self.log_filename = log_filename
        self.data = {}
        self.parameters = {}
        self.load_data()
    
    def load_data(self):
        """Load spline data from log file"""
        if not os.path.exists(self.log_filename):
            raise FileNotFoundError(f"Log file not found: {self.log_filename}")
        
        with open(self.log_filename, 'r') as f:
            lines = f.readlines()
        
        # Parse parameters from header
        for line in lines:
            if line.startswith('# v_max:'):
                self.parameters['v_max'] = float(line.split(':')[1].strip().split()[0])
            elif line.startswith('# a_max:'):
                self.parameters['a_max'] = float(line.split(':')[1].strip().split()[0])
            elif line.startswith('# a_lat_max:'):
                self.parameters['a_lat_max'] = float(line.split(':')[1].strip().split()[0])
            elif line.startswith('# t_start:'):
                self.parameters['t_start'] = float(line.split(':')[1].strip().split()[0])
            elif line.startswith('# t_finish:'):
                self.parameters['t_finish'] = float(line.split(':')[1].strip().split()[0])
            elif line.startswith('# samples:'):
                self.parameters['samples'] = int(line.split(':')[1].strip())
            elif line.startswith('# total_arc_length:'):
                self.parameters['total_arc_length'] = float(line.split(':')[1].strip().split()[0])
            elif line.startswith('# total_time:'):
                self.parameters['total_time'] = float(line.split(':')[1].strip().split()[0])
        
        # Parse data
        data_lines = [line for line in lines if not line.startswith('#')]
        
        arrays = {
            'index': [], 'u': [], 'pos_x': [], 'pos_y': [],
            'd1_x': [], 'd1_y': [], 'd2_x': [], 'd2_y': [],
            'arc_length': [], 'curvature': [], 'velocity': [], 'time': []
        }
        
        for line in data_lines:
            if line.strip():
                values = line.strip().split()
                if len(values) >= 12:
                    arrays['index'].append(int(values[0]))
                    arrays['u'].append(float(values[1]))
                    arrays['pos_x'].append(float(values[2]))
                    arrays['pos_y'].append(float(values[3]))
                    arrays['d1_x'].append(float(values[4]))
                    arrays['d1_y'].append(float(values[5]))
                    arrays['d2_x'].append(float(values[6]))
                    arrays['d2_y'].append(float(values[7]))
                    arrays['arc_length'].append(float(values[8]))
                    arrays['curvature'].append(float(values[9]))
                    arrays['velocity'].append(float(values[10]))
                    arrays['time'].append(float(values[11]))
        
        # Convert to numpy arrays
        for key in arrays:
            self.data[key] = np.array(arrays[key])
        
        print(f"Loaded {len(self.data['index'])} data points from {self.log_filename}")
        print(f"Parameters: {self.parameters}")
    
    def verify_velocity_constraints(self) -> Dict[str, bool]:
        """Verify velocity profile constraints"""
        results = {}
        
        # Check maximum velocity constraint
        max_vel = np.max(self.data['velocity'])
        results['max_velocity_ok'] = max_vel <= self.parameters['v_max'] + 1e-6
        
        # Check acceleration constraints
        dt_array = np.diff(self.data['time'])
        dv_array = np.diff(self.data['velocity'])
        
        # Avoid division by very small dt
        valid_indices = dt_array > 1e-9
        accelerations = np.zeros_like(dt_array)
        accelerations[valid_indices] = dv_array[valid_indices] / dt_array[valid_indices]
        
        max_accel = np.max(np.abs(accelerations[valid_indices])) if np.any(valid_indices) else 0
        results['max_acceleration_ok'] = max_accel <= self.parameters['a_max'] + 1e-3  # Allow small tolerance
        
        # Check lateral acceleration constraints (v²κ ≤ a_lat_max)
        lateral_accels = self.data['velocity']**2 * self.data['curvature']
        max_lat_accel = np.max(lateral_accels)
        results['max_lateral_acceleration_ok'] = max_lat_accel <= self.parameters['a_lat_max'] + 1e-3
        
        # Check boundary conditions
        results['starts_at_rest'] = self.data['velocity'][0] < 1e-6
        results['ends_at_rest'] = self.data['velocity'][-1] < 1e-6
        
        return results
    
    def verify_curvature_calculation(self) -> Dict[str, bool]:
        """Verify curvature calculations using finite differences"""
        results = {}
        
        # Calculate curvature using finite differences for comparison
        pos_x = self.data['pos_x']
        pos_y = self.data['pos_y']
        
        # First derivatives (finite difference approximation)
        dx_fd = np.gradient(pos_x, self.data['u'])
        dy_fd = np.gradient(pos_y, self.data['u'])
        
        # Second derivatives
        d2x_fd = np.gradient(dx_fd, self.data['u'])
        d2y_fd = np.gradient(dy_fd, self.data['u'])
        
        # Curvature formula: |x'y'' - y'x''| / (x'² + y'²)^(3/2)
        numerator = np.abs(dx_fd * d2y_fd - dy_fd * d2x_fd)
        denominator = (dx_fd**2 + dy_fd**2)**(3/2)
        
        # Avoid division by zero
        valid_mask = denominator > 1e-9
        curvature_fd = np.zeros_like(numerator)
        curvature_fd[valid_mask] = numerator[valid_mask] / denominator[valid_mask]
        
        # Compare with logged curvature (allow some tolerance due to different methods)
        curvature_diff = np.abs(self.data['curvature'] - curvature_fd)
        max_curvature_error = np.max(curvature_diff[valid_mask]) if np.any(valid_mask) else 0
        
        results['curvature_calculation_ok'] = max_curvature_error < 0.1  # Allow reasonable tolerance
        results['max_curvature_error'] = max_curvature_error
        
        return results
    
    def verify_arc_length_consistency(self) -> Dict[str, bool]:
        """Verify arc length calculations"""
        results = {}
        
        # Calculate arc length using position differences
        pos_diff = np.sqrt(np.diff(self.data['pos_x'])**2 + np.diff(self.data['pos_y'])**2)
        arc_length_fd = np.zeros_like(self.data['arc_length'])
        arc_length_fd[1:] = np.cumsum(pos_diff)
        
        # Compare with logged arc length
        arc_diff = np.abs(self.data['arc_length'] - arc_length_fd)
        max_arc_error = np.max(arc_diff)
        
        # Allow some tolerance due to different integration methods
        results['arc_length_consistent'] = max_arc_error < self.parameters['total_arc_length'] * 0.01
        results['max_arc_error'] = max_arc_error
        
        # Check monotonicity
        arc_diffs = np.diff(self.data['arc_length'])
        results['arc_length_monotonic'] = np.all(arc_diffs >= -1e-9)  # Allow tiny numerical errors
        
        return results
    
    def verify_time_consistency(self) -> Dict[str, bool]:
        """Verify time calculations"""
        results = {}
        
        # Check time monotonicity
        time_diffs = np.diff(self.data['time'])
        results['time_monotonic'] = np.all(time_diffs >= -1e-9)
        
        # Check if total time matches parameter
        calculated_total_time = self.data['time'][-1] - self.data['time'][0]
        results['total_time_consistent'] = abs(calculated_total_time - self.parameters['total_time']) < 1e-6
        
        # Verify time calculation: dt = ds / v_avg
        for i in range(1, len(self.data['time'])):
            ds = self.data['arc_length'][i] - self.data['arc_length'][i-1]
            v_avg = 0.5 * (self.data['velocity'][i] + self.data['velocity'][i-1])
            if v_avg > 1e-9:
                expected_dt = ds / v_avg
                actual_dt = self.data['time'][i] - self.data['time'][i-1]
                # Allow some tolerance for the first few checks
                if i <= 3:  # Check only first few points for detailed verification
                    time_error = abs(expected_dt - actual_dt)
                    if time_error > 1e-3:  # 1ms tolerance
                        results[f'time_calculation_ok_point_{i}'] = False
                        break
            else:
                results[f'zero_velocity_at_point_{i}'] = True
        
        return results
    
    def generate_verification_report(self) -> str:
        """Generate comprehensive verification report"""
        report = []
        report.append("=" * 80)
        report.append("SPLINE2D VERIFICATION REPORT")
        report.append("=" * 80)
        report.append(f"Log file: {self.log_filename}")
        report.append(f"Data points: {len(self.data['index'])}")
        report.append("")
        
        # Parameters
        report.append("PARAMETERS:")
        for key, value in self.parameters.items():
            report.append(f"  {key}: {value}")
        report.append("")
        
        # Velocity constraints
        report.append("VELOCITY CONSTRAINTS:")
        vel_results = self.verify_velocity_constraints()
        for key, result in vel_results.items():
            status = "✓ PASS" if result else "✗ FAIL"
            report.append(f"  {key}: {status}")
        report.append("")
        
        # Curvature verification
        report.append("CURVATURE VERIFICATION:")
        curv_results = self.verify_curvature_calculation()
        for key, result in curv_results.items():
            if isinstance(result, bool):
                status = "✓ PASS" if result else "✗ FAIL"
                report.append(f"  {key}: {status}")
            else:
                report.append(f"  {key}: {result:.6f}")
        report.append("")
        
        # Arc length consistency
        report.append("ARC LENGTH CONSISTENCY:")
        arc_results = self.verify_arc_length_consistency()
        for key, result in arc_results.items():
            if isinstance(result, bool):
                status = "✓ PASS" if result else "✗ FAIL"
                report.append(f"  {key}: {status}")
            else:
                report.append(f"  {key}: {result:.6f}")
        report.append("")
        
        # Time consistency
        report.append("TIME CONSISTENCY:")
        time_results = self.verify_time_consistency()
        for key, result in time_results.items():
            if isinstance(result, bool):
                status = "✓ PASS" if result else "✗ FAIL"
                report.append(f"  {key}: {status}")
            else:
                report.append(f"  {key}: {result}")
        report.append("")
        
        # Summary
        all_results = {**vel_results, **curv_results, **arc_results, **time_results}
        passed = sum(1 for v in all_results.values() if isinstance(v, bool) and v)
        total = sum(1 for v in all_results.values() if isinstance(v, bool))
        
        report.append("SUMMARY:")
        report.append(f"  Tests passed: {passed}/{total}")
        overall_status = "✓ OVERALL PASS" if passed == total else "✗ OVERALL FAIL"
        report.append(f"  Overall status: {overall_status}")
        report.append("=" * 80)
        
        return "\n".join(report)
    
    def plot_verification_graphs(self, save_plots: bool = False):
        """Generate verification plots"""
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        fig.suptitle('Spline2D Verification Plots', fontsize=16)
        
        # Trajectory plot
        axes[0, 0].plot(self.data['pos_x'], self.data['pos_y'], 'b-', linewidth=2, label='Spline path')
        axes[0, 0].plot(self.data['pos_x'][0], self.data['pos_y'][0], 'go', markersize=8, label='Start')
        axes[0, 0].plot(self.data['pos_x'][-1], self.data['pos_y'][-1], 'ro', markersize=8, label='End')
        axes[0, 0].set_xlabel('X (m)')
        axes[0, 0].set_ylabel('Y (m)')
        axes[0, 0].set_title('2D Trajectory')
        axes[0, 0].legend()
        axes[0, 0].grid(True)
        axes[0, 0].axis('equal')
        
        # Velocity profile
        axes[0, 1].plot(self.data['time'], self.data['velocity'], 'b-', linewidth=2, label='Velocity')
        axes[0, 1].axhline(y=self.parameters['v_max'], color='r', linestyle='--', label=f'v_max = {self.parameters["v_max"]:.2f}')
        axes[0, 1].set_xlabel('Time (s)')
        axes[0, 1].set_ylabel('Velocity (m/s)')
        axes[0, 1].set_title('Velocity Profile')
        axes[0, 1].legend()
        axes[0, 1].grid(True)
        
        # Acceleration profile
        dt_array = np.diff(self.data['time'])
        dv_array = np.diff(self.data['velocity'])
        valid_indices = dt_array > 1e-9
        accelerations = np.zeros_like(dt_array)
        accelerations[valid_indices] = dv_array[valid_indices] / dt_array[valid_indices]
        
        time_mid = 0.5 * (self.data['time'][1:] + self.data['time'][:-1])
        axes[0, 2].plot(time_mid, accelerations, 'g-', linewidth=2, label='Acceleration')
        axes[0, 2].axhline(y=self.parameters['a_max'], color='r', linestyle='--', label=f'a_max = {self.parameters["a_max"]:.2f}')
        axes[0, 2].axhline(y=-self.parameters['a_max'], color='r', linestyle='--', label=f'-a_max = {-self.parameters["a_max"]:.2f}')
        axes[0, 2].set_xlabel('Time (s)')
        axes[0, 2].set_ylabel('Acceleration (m/s²)')
        axes[0, 2].set_title('Acceleration Profile')
        axes[0, 2].legend()
        axes[0, 2].grid(True)
        
        # Curvature profile
        axes[1, 0].plot(self.data['arc_length'], self.data['curvature'], 'm-', linewidth=2, label='Curvature')
        axes[1, 0].set_xlabel('Arc Length (m)')
        axes[1, 0].set_ylabel('Curvature (1/m)')
        axes[1, 0].set_title('Curvature vs Arc Length')
        axes[1, 0].legend()
        axes[1, 0].grid(True)
        
        # Lateral acceleration
        lateral_accels = self.data['velocity']**2 * self.data['curvature']
        axes[1, 1].plot(self.data['time'], lateral_accels, 'c-', linewidth=2, label='Lateral Acceleration')
        axes[1, 1].axhline(y=self.parameters['a_lat_max'], color='r', linestyle='--', label=f'a_lat_max = {self.parameters["a_lat_max"]:.2f}')
        axes[1, 1].set_xlabel('Time (s)')
        axes[1, 1].set_ylabel('Lateral Acceleration (m/s²)')
        axes[1, 1].set_title('Lateral Acceleration Profile')
        axes[1, 1].legend()
        axes[1, 1].grid(True)
        
        # Arc length vs time
        axes[1, 2].plot(self.data['time'], self.data['arc_length'], 'orange', linewidth=2, label='Arc Length')
        axes[1, 2].set_xlabel('Time (s)')
        axes[1, 2].set_ylabel('Arc Length (m)')
        axes[1, 2].set_title('Arc Length vs Time')
        axes[1, 2].legend()
        axes[1, 2].grid(True)
        
        plt.tight_layout()
        
        if save_plots:
            plot_filename = self.log_filename.replace('.log', '_verification_plots.png')
            plt.savefig(plot_filename, dpi=300, bbox_inches='tight')
            print(f"Plots saved to: {plot_filename}")
        
        plt.show()


def main():
    parser = argparse.ArgumentParser(description='Verify Spline2D generated data')
    parser.add_argument('log_file', help='Path to the spline log file')
    parser.add_argument('--save-plots', action='store_true', help='Save verification plots to file')
    parser.add_argument('--save-report', action='store_true', help='Save verification report to file')
    parser.add_argument('--show-plots', action='store_true', default=True, help='Show verification plots')
    
    args = parser.parse_args()
    
    try:
        # Create verifier and run verification
        verifier = SplineVerifier(args.log_file)
        
        # Generate and display report
        report = verifier.generate_verification_report()
        print(report)
        
        # Save report if requested
        if args.save_report:
            report_filename = args.log_file.replace('.log', '_verification_report.txt')
            with open(report_filename, 'w') as f:
                f.write(report)
            print(f"\nReport saved to: {report_filename}")
        
        # Generate plots
        if args.show_plots or args.save_plots:
            verifier.plot_verification_graphs(save_plots=args.save_plots)
        
    except Exception as e:
        print(f"Error: {e}")
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())