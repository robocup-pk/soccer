#!/usr/bin/env python3
"""
Plot Kalman Filter Analysis Results
Reads the log file generated by demo_kalman_logging and creates comprehensive plots
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from matplotlib.patches import Rectangle
import sys

def read_kalman_log(filename='kalman_filter_log.txt'):
    """Read and parse the Kalman filter log file"""
    
    data = {
        'timestamp': [],
        'actual_x': [], 'actual_y': [], 'actual_theta': [],
        'estimated_x': [], 'estimated_y': [], 'estimated_theta': [],
        'dead_reckoning_x': [], 'dead_reckoning_y': [], 'dead_reckoning_theta': [],
        'camera_update': [],
        'error_x': [], 'error_y': [], 'error_theta': [],
        'dr_error_x': [], 'dr_error_y': [], 'dr_error_theta': []
    }
    
    waypoints = []
    trajectory_type = ""
    camera_period_ms = 50
    
    with open(filename, 'r') as f:
        for line in f:
            if line.startswith('# Camera Update Period:'):
                camera_period_ms = float(line.split()[-2])
            elif line.startswith('# Trajectory:'):
                trajectory_type = line.split(':')[1].strip()
            elif line.startswith('# WP'):
                parts = line.split()
                waypoints.append([float(parts[3]), float(parts[4]), float(parts[5])])
            elif not line.startswith('#') and line.strip():
                parts = line.strip().split()
                if len(parts) >= 17:  # Now we have more fields with dead reckoning
                    data['timestamp'].append(float(parts[0]))
                    data['actual_x'].append(float(parts[1]))
                    data['actual_y'].append(float(parts[2]))
                    data['actual_theta'].append(float(parts[3]))
                    data['estimated_x'].append(float(parts[4]))
                    data['estimated_y'].append(float(parts[5]))
                    data['estimated_theta'].append(float(parts[6]))
                    data['dead_reckoning_x'].append(float(parts[7]))
                    data['dead_reckoning_y'].append(float(parts[8]))
                    data['dead_reckoning_theta'].append(float(parts[9]))
                    data['camera_update'].append(int(parts[10]))
                    data['error_x'].append(float(parts[11]))
                    data['error_y'].append(float(parts[12]))
                    data['error_theta'].append(float(parts[13]))
                    data['dr_error_x'].append(float(parts[14]))
                    data['dr_error_y'].append(float(parts[15]))
                    data['dr_error_theta'].append(float(parts[16]))
                elif len(parts) >= 11:  # Fallback for old format
                    # Old format without dead reckoning - fill with NaN
                    data['timestamp'].append(float(parts[0]))
                    data['actual_x'].append(float(parts[1]))
                    data['actual_y'].append(float(parts[2]))
                    data['actual_theta'].append(float(parts[3]))
                    data['estimated_x'].append(float(parts[4]))
                    data['estimated_y'].append(float(parts[5]))
                    data['estimated_theta'].append(float(parts[6]))
                    data['dead_reckoning_x'].append(float(parts[4]))  # Use Kalman as fallback
                    data['dead_reckoning_y'].append(float(parts[5]))
                    data['dead_reckoning_theta'].append(float(parts[6]))
                    data['camera_update'].append(int(parts[7]))
                    data['error_x'].append(float(parts[8]))
                    data['error_y'].append(float(parts[9]))
                    data['error_theta'].append(float(parts[10]))
                    data['dr_error_x'].append(float(parts[8]))  # Use same as Kalman
                    data['dr_error_y'].append(float(parts[9]))
                    data['dr_error_theta'].append(float(parts[10]))
    
    # Convert to numpy arrays
    for key in data:
        data[key] = np.array(data[key])
    
    return data, waypoints, trajectory_type, camera_period_ms

def calculate_statistics(data):
    """Calculate error statistics"""
    stats = {}
    
    # Kalman filter position error magnitude
    position_error = np.sqrt(data['error_x']**2 + data['error_y']**2)
    
    # Dead reckoning position error magnitude
    dr_position_error = np.sqrt(data['dr_error_x']**2 + data['dr_error_y']**2)
    
    stats['x_mean'] = np.mean(data['error_x']) * 1000  # Convert to mm
    stats['x_std'] = np.std(data['error_x']) * 1000
    stats['x_rmse'] = np.sqrt(np.mean(data['error_x']**2)) * 1000
    stats['x_max'] = np.max(np.abs(data['error_x'])) * 1000
    
    stats['y_mean'] = np.mean(data['error_y']) * 1000
    stats['y_std'] = np.std(data['error_y']) * 1000
    stats['y_rmse'] = np.sqrt(np.mean(data['error_y']**2)) * 1000
    stats['y_max'] = np.max(np.abs(data['error_y'])) * 1000
    
    stats['theta_mean'] = np.mean(data['error_theta']) * 180/np.pi  # Convert to degrees
    stats['theta_std'] = np.std(data['error_theta']) * 180/np.pi
    stats['theta_rmse'] = np.sqrt(np.mean(data['error_theta']**2)) * 180/np.pi
    stats['theta_max'] = np.max(np.abs(data['error_theta'])) * 180/np.pi
    
    stats['position_mean'] = np.mean(position_error) * 1000
    stats['position_std'] = np.std(position_error) * 1000
    stats['position_rmse'] = np.sqrt(np.mean(position_error**2)) * 1000
    stats['position_max'] = np.max(position_error) * 1000
    
    # Dead reckoning statistics
    stats['dr_x_mean'] = np.mean(data['dr_error_x']) * 1000
    stats['dr_x_std'] = np.std(data['dr_error_x']) * 1000
    stats['dr_x_rmse'] = np.sqrt(np.mean(data['dr_error_x']**2)) * 1000
    stats['dr_x_max'] = np.max(np.abs(data['dr_error_x'])) * 1000
    
    stats['dr_y_mean'] = np.mean(data['dr_error_y']) * 1000
    stats['dr_y_std'] = np.std(data['dr_error_y']) * 1000
    stats['dr_y_rmse'] = np.sqrt(np.mean(data['dr_error_y']**2)) * 1000
    stats['dr_y_max'] = np.max(np.abs(data['dr_error_y'])) * 1000
    
    stats['dr_theta_mean'] = np.mean(data['dr_error_theta']) * 180/np.pi
    stats['dr_theta_std'] = np.std(data['dr_error_theta']) * 180/np.pi
    stats['dr_theta_rmse'] = np.sqrt(np.mean(data['dr_error_theta']**2)) * 180/np.pi
    stats['dr_theta_max'] = np.max(np.abs(data['dr_error_theta'])) * 180/np.pi
    
    stats['dr_position_mean'] = np.mean(dr_position_error) * 1000
    stats['dr_position_std'] = np.std(dr_position_error) * 1000
    stats['dr_position_rmse'] = np.sqrt(np.mean(dr_position_error**2)) * 1000
    stats['dr_position_max'] = np.max(dr_position_error) * 1000
    
    return stats

def plot_results(data, waypoints, trajectory_type, camera_period_ms, stats):
    """Create comprehensive visualization"""
    
    # Create figure with subplots
    fig = plt.figure(figsize=(16, 12))
    
    # Main trajectory plot
    ax1 = plt.subplot(3, 3, (1, 4))
    
    # Mark camera updates first (lowest z-order) with bigger, more visible markers
    camera_indices = data['camera_update'] == 1
    ax1.scatter(data['actual_x'][camera_indices], data['actual_y'][camera_indices], 
                c='lime', s=50, marker='o', alpha=0.6, label='Camera Updates', zorder=1, edgecolors='darkgreen')
    
    # Plot trajectories with increasing z-order
    ax1.plot(data['actual_x'], data['actual_y'], 'b-', linewidth=2, label='Actual Trajectory', 
             alpha=0.7, zorder=2)
    ax1.plot(data['estimated_x'], data['estimated_y'], 'r--', linewidth=2, label='Kalman Filter', 
             alpha=0.8, zorder=3)
    # Dead reckoning on top with highest z-order
    ax1.plot(data['dead_reckoning_x'], data['dead_reckoning_y'], 'darkorange', linewidth=2.5, 
             label='Dead Reckoning', alpha=0.9, linestyle='-.', zorder=4)
    
    # Mark waypoints
    if waypoints:
        wp_array = np.array(waypoints)
        ax1.scatter(wp_array[:, 0], wp_array[:, 1], c='orange', s=100, marker='*', 
                   label='Waypoints', zorder=6, edgecolors='black')
    
    # Mark start and end
    ax1.scatter(data['actual_x'][0], data['actual_y'][0], c='green', s=150, 
               marker='o', label='Start', zorder=7, edgecolors='black')
    ax1.scatter(data['actual_x'][-1], data['actual_y'][-1], c='red', s=150, 
               marker='s', label='End', zorder=7, edgecolors='black')
    
    ax1.set_xlabel('X Position (m)', fontsize=11)
    ax1.set_ylabel('Y Position (m)', fontsize=11)
    ax1.set_title(f'Trajectory Comparison: {trajectory_type}\n(Camera @ {1000/camera_period_ms:.1f}Hz, period={camera_period_ms}ms)', 
                  fontsize=12, fontweight='bold')
    ax1.legend(loc='best')
    ax1.grid(True, alpha=0.3)
    ax1.axis('equal')
    
    # X Error over time
    ax2 = plt.subplot(3, 3, 2)
    ax2.plot(data['timestamp'], data['error_x']*1000, 'b-', alpha=0.7)
    ax2.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    ax2.axhline(y=stats['x_mean'], color='r', linestyle='--', 
                label=f'Mean: {stats["x_mean"]:.2f}mm')
    ax2.fill_between(data['timestamp'], 
                     (stats['x_mean'] - stats['x_std']),
                     (stats['x_mean'] + stats['x_std']),
                     alpha=0.3, color='r')
    
    # Mark camera updates
    for t in data['timestamp'][camera_indices]:
        ax2.axvline(x=t, color='cyan', alpha=0.1, linestyle=':')
    
    ax2.set_xlabel('Time (s)')
    ax2.set_ylabel('X Error (mm)')
    ax2.set_title(f'X Position Error\nRMSE: {stats["x_rmse"]:.2f}mm')
    ax2.legend(fontsize=8)
    ax2.grid(True, alpha=0.3)
    
    # Y Error over time
    ax3 = plt.subplot(3, 3, 3)
    ax3.plot(data['timestamp'], data['error_y']*1000, 'g-', alpha=0.7)
    ax3.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    ax3.axhline(y=stats['y_mean'], color='r', linestyle='--', 
                label=f'Mean: {stats["y_mean"]:.2f}mm')
    ax3.fill_between(data['timestamp'],
                     (stats['y_mean'] - stats['y_std']),
                     (stats['y_mean'] + stats['y_std']),
                     alpha=0.3, color='r')
    
    # Mark camera updates
    for t in data['timestamp'][camera_indices]:
        ax3.axvline(x=t, color='cyan', alpha=0.1, linestyle=':')
    
    ax3.set_xlabel('Time (s)')
    ax3.set_ylabel('Y Error (mm)')
    ax3.set_title(f'Y Position Error\nRMSE: {stats["y_rmse"]:.2f}mm')
    ax3.legend(fontsize=8)
    ax3.grid(True, alpha=0.3)
    
    # Theta Error over time
    ax4 = plt.subplot(3, 3, 5)
    ax4.plot(data['timestamp'], data['error_theta']*180/np.pi, 'r-', alpha=0.7)
    ax4.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    ax4.axhline(y=stats['theta_mean'], color='k', linestyle='--', 
                label=f'Mean: {stats["theta_mean"]:.2f}°')
    ax4.fill_between(data['timestamp'],
                     (stats['theta_mean'] - stats['theta_std']),
                     (stats['theta_mean'] + stats['theta_std']),
                     alpha=0.3, color='k')
    
    # Mark camera updates
    for t in data['timestamp'][camera_indices]:
        ax4.axvline(x=t, color='cyan', alpha=0.1, linestyle=':')
    
    ax4.set_xlabel('Time (s)')
    ax4.set_ylabel('Theta Error (degrees)')
    ax4.set_title(f'Orientation Error\nRMSE: {stats["theta_rmse"]:.2f}°')
    ax4.legend(fontsize=8)
    ax4.grid(True, alpha=0.3)
    
    # Position error magnitude over time - comparing Kalman and Dead Reckoning
    ax5 = plt.subplot(3, 3, 6)
    position_error = np.sqrt(data['error_x']**2 + data['error_y']**2) * 1000
    dr_position_error = np.sqrt(data['dr_error_x']**2 + data['dr_error_y']**2) * 1000
    ax5.plot(data['timestamp'], position_error, 'r-', alpha=0.8, linewidth=1.5, label='Kalman Filter')
    ax5.plot(data['timestamp'], dr_position_error, 'orange', alpha=0.8, linewidth=2, 
             linestyle='-.', label='Dead Reckoning')
    ax5.axhline(y=stats['position_mean'], color='r', linestyle='--', alpha=0.5)
    ax5.axhline(y=stats['dr_position_mean'], color='orange', linestyle='--', alpha=0.5)
    
    # Mark camera updates
    for t in data['timestamp'][camera_indices]:
        ax5.axvline(x=t, color='cyan', alpha=0.1, linestyle=':')
    
    ax5.set_xlabel('Time (s)')
    ax5.set_ylabel('Position Error Magnitude (mm)')
    ax5.set_title(f'Position Error Comparison\nKalman RMSE: {stats["position_rmse"]:.2f}mm, DR RMSE: {stats["dr_position_rmse"]:.2f}mm')
    ax5.legend(fontsize=8)
    ax5.grid(True, alpha=0.3)
    
    # Error histograms
    ax6 = plt.subplot(3, 3, 7)
    ax6.hist(data['error_x']*1000, bins=30, alpha=0.7, color='b', edgecolor='black')
    ax6.axvline(x=0, color='k', linestyle='-', alpha=0.5)
    ax6.set_xlabel('X Error (mm)')
    ax6.set_ylabel('Frequency')
    ax6.set_title(f'X Error Distribution\nMax: {stats["x_max"]:.2f}mm')
    ax6.grid(True, alpha=0.3)
    
    ax7 = plt.subplot(3, 3, 8)
    ax7.hist(data['error_y']*1000, bins=30, alpha=0.7, color='g', edgecolor='black')
    ax7.axvline(x=0, color='k', linestyle='-', alpha=0.5)
    ax7.set_xlabel('Y Error (mm)')
    ax7.set_ylabel('Frequency')
    ax7.set_title(f'Y Error Distribution\nMax: {stats["y_max"]:.2f}mm')
    ax7.grid(True, alpha=0.3)
    
    ax8 = plt.subplot(3, 3, 9)
    ax8.hist(data['error_theta']*180/np.pi, bins=30, alpha=0.7, color='r', edgecolor='black')
    ax8.axvline(x=0, color='k', linestyle='-', alpha=0.5)
    ax8.set_xlabel('Theta Error (degrees)')
    ax8.set_ylabel('Frequency')
    ax8.set_title(f'Theta Error Distribution\nMax: {stats["theta_max"]:.2f}°')
    ax8.grid(True, alpha=0.3)
    
    # Add main title
    fig.suptitle('Kalman Filter Performance Analysis (Camera + Encoder Fusion, No Gyro)', 
                 fontsize=14, fontweight='bold')
    
    # Add statistics summary text box
    stats_text = f"""Summary Statistics:
    
KALMAN FILTER:
  X: RMSE={stats['x_rmse']:.2f}mm, Max={stats['x_max']:.2f}mm
  Y: RMSE={stats['y_rmse']:.2f}mm, Max={stats['y_max']:.2f}mm
  Total: RMSE={stats['position_rmse']:.2f}mm, Max={stats['position_max']:.2f}mm
  θ: RMSE={stats['theta_rmse']:.2f}°, Max={stats['theta_max']:.2f}°
  
DEAD RECKONING:
  X: RMSE={stats['dr_x_rmse']:.2f}mm, Max={stats['dr_x_max']:.2f}mm
  Y: RMSE={stats['dr_y_rmse']:.2f}mm, Max={stats['dr_y_max']:.2f}mm
  Total: RMSE={stats['dr_position_rmse']:.2f}mm, Max={stats['dr_position_max']:.2f}mm
  θ: RMSE={stats['dr_theta_rmse']:.2f}°, Max={stats['dr_theta_max']:.2f}°
  
Total Samples: {len(data['timestamp'])}
Camera Updates: {np.sum(data['camera_update'])}"""
    
    fig.text(0.02, 0.02, stats_text, fontsize=9, 
             bbox=dict(boxstyle="round,pad=0.5", facecolor="lightgray", alpha=0.8),
             verticalalignment='bottom', family='monospace')
    
    plt.tight_layout(rect=[0, 0.12, 1, 0.96])
    
    return fig

def main():
    """Main function"""
    print("=" * 60)
    print("Kalman Filter Analysis - Real-time Data from C++ Demo")
    print("=" * 60)
    
    # Read log file
    try:
        data, waypoints, trajectory_type, camera_period_ms = read_kalman_log('kalman_filter_log.txt')
    except FileNotFoundError:
        print("\nError: kalman_filter_log.txt not found!")
        print("Please run the demo first: ./build/libs/algos/demo/demo_kalman_logging")
        sys.exit(1)
    
    if len(data['timestamp']) == 0:
        print("\nError: No data found in log file!")
        sys.exit(1)
    
    print(f"\nTrajectory Type: {trajectory_type}")
    print(f"Camera Update Period: {camera_period_ms} ms ({1000/camera_period_ms:.1f} Hz)")
    print(f"Total Samples: {len(data['timestamp'])}")
    print(f"Camera Updates: {np.sum(data['camera_update'])}")
    print(f"Duration: {data['timestamp'][-1]:.2f} seconds")
    
    # Calculate statistics
    stats = calculate_statistics(data)
    
    # Print statistics
    print("\n" + "=" * 40)
    print("ERROR STATISTICS")
    print("=" * 40)
    
    print("\nPosition Error (mm):")
    print(f"  X-axis:")
    print(f"    Mean:  {stats['x_mean']:8.3f}")
    print(f"    Std:   {stats['x_std']:8.3f}")
    print(f"    RMSE:  {stats['x_rmse']:8.3f}")
    print(f"    Max:   {stats['x_max']:8.3f}")
    
    print(f"\n  Y-axis:")
    print(f"    Mean:  {stats['y_mean']:8.3f}")
    print(f"    Std:   {stats['y_std']:8.3f}")
    print(f"    RMSE:  {stats['y_rmse']:8.3f}")
    print(f"    Max:   {stats['y_max']:8.3f}")
    
    print(f"\n  Total Position:")
    print(f"    Mean:  {stats['position_mean']:8.3f}")
    print(f"    Std:   {stats['position_std']:8.3f}")
    print(f"    RMSE:  {stats['position_rmse']:8.3f}")
    print(f"    Max:   {stats['position_max']:8.3f}")
    
    print(f"\nOrientation Error (degrees):")
    print(f"    Mean:  {stats['theta_mean']:8.3f}")
    print(f"    Std:   {stats['theta_std']:8.3f}")
    print(f"    RMSE:  {stats['theta_rmse']:8.3f}")
    print(f"    Max:   {stats['theta_max']:8.3f}")
    
    print("\n" + "=" * 40)
    print("DEAD RECKONING STATISTICS")
    print("=" * 40)
    
    print("\nDead Reckoning Position Error (mm):")
    print(f"  X-axis:")
    print(f"    Mean:  {stats['dr_x_mean']:8.3f}")
    print(f"    Std:   {stats['dr_x_std']:8.3f}")
    print(f"    RMSE:  {stats['dr_x_rmse']:8.3f}")
    print(f"    Max:   {stats['dr_x_max']:8.3f}")
    
    print(f"\n  Y-axis:")
    print(f"    Mean:  {stats['dr_y_mean']:8.3f}")
    print(f"    Std:   {stats['dr_y_std']:8.3f}")
    print(f"    RMSE:  {stats['dr_y_rmse']:8.3f}")
    print(f"    Max:   {stats['dr_y_max']:8.3f}")
    
    print(f"\n  Total Position:")
    print(f"    Mean:  {stats['dr_position_mean']:8.3f}")
    print(f"    Std:   {stats['dr_position_std']:8.3f}")
    print(f"    RMSE:  {stats['dr_position_rmse']:8.3f}")
    print(f"    Max:   {stats['dr_position_max']:8.3f}")
    
    print(f"\nDead Reckoning Orientation Error (degrees):")
    print(f"    Mean:  {stats['dr_theta_mean']:8.3f}")
    print(f"    Std:   {stats['dr_theta_std']:8.3f}")
    print(f"    RMSE:  {stats['dr_theta_rmse']:8.3f}")
    print(f"    Max:   {stats['dr_theta_max']:8.3f}")
    
    # Create plots
    print("\nGenerating plots...")
    fig = plot_results(data, waypoints, trajectory_type, camera_period_ms, stats)
    
    # Save figure
    output_file = 'kalman_filter_analysis.png'
    plt.savefig(output_file, dpi=150, bbox_inches='tight')
    print(f"Plots saved to '{output_file}'")
    
    # Show plot
    plt.show()
    
    return stats

if __name__ == "__main__":
    stats = main()