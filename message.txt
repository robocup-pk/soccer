class SplineController {
private:
    double kp_longitudinal_, ki_longitudinal_, kd_longitudinal_;
    double kp_lateral_;
    double desired_speed_;
    double t_error_integral_;
    double t_error_prev_;
    
public:
    Eigen::Vector3d computeControl(const Spline& spline, 
                                  const Eigen::Vector3d& current_pose,
                                  double current_time) {
        // 1. Compute desired parameter based on time and speed
        double t_desired = computeDesiredParameter(current_time);
        
        // 2. Find actual parameter (closest point on spline)
        double t_actual = spline.getClosestParameter(current_pose.head<2>());
        
        // 3. Longitudinal control (along path)
        double t_error = t_desired - t_actual;
        t_error_integral_ += t_error * dt_;
        double t_error_dot = (t_error - t_error_prev_) / dt_;
        
        double t_dot_command = kp_longitudinal_ * t_error + 
                              ki_longitudinal_ * t_error_integral_ + 
                              kd_longitudinal_ * t_error_dot;
        
        // 4. Get path direction and base velocity
        Eigen::Vector2d tangent = spline.getTangent(t_actual).head<2>().normalized();
        Eigen::Vector2d velocity_long = t_dot_command * desired_speed_ * tangent;
        
        // 5. Lateral control (cross-track error)
        Eigen::Vector2d current_pos = current_pose.head<2>();
        Eigen::Vector2d closest_point = spline.getPoint(t_actual).head<2>();
        Eigen::Vector2d cross_track = current_pos - closest_point;
        
        Eigen::Vector2d normal(-tangent[1], tangent[0]);
        double lateral_error = cross_track.dot(normal);
        Eigen::Vector2d velocity_lat = -kp_lateral_ * lateral_error * normal;
        
        // 6. Combine and add angular control
        Eigen::Vector3d velocity_command;
        velocity_command.head<2>() = velocity_long + velocity_lat;
        
        // Angular control to match path heading
        double desired_heading = atan2(tangent[1], tangent[0]);
        double heading_error = desired_heading - current_pose[2];
        // Normalize angle
        while (heading_error > M_PI) heading_error -= 2*M_PI;
        while (heading_error < -M_PI) heading_error += 2*M_PI;
        
        velocity_command[2] = kp_angular_ * heading_error;
        
        t_error_prev_ = t_error;
        return velocity_command;
    }
};