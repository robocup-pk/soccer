\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{B-Spline Trajectory Planning for RRT* Waypoint Following in SSL Robot Soccer}
\author{Technical Documentation}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document provides a comprehensive mathematical and implementation overview of the B-spline trajectory planner developed for smooth waypoint following in Small Size League (SSL) robot soccer. The planner addresses the challenge of generating smooth, dynamically feasible trajectories from discrete waypoints produced by the RRT* path planning algorithm. The implementation features C2 continuous trajectories, arc-length parameterization, and trapezoidal velocity profiles to ensure smooth robot motion while respecting kinematic constraints.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

The RRT* (Rapidly-exploring Random Tree Star) algorithm is widely used in robot path planning for its ability to find collision-free paths in complex environments. However, RRT* produces a sequence of discrete waypoints that, when followed directly, can result in jerky, unnatural robot motion with velocity discontinuities at waypoints.

This document describes a B-spline based trajectory planning approach that transforms RRT* waypoints into smooth, continuous trajectories suitable for omnidirectional robot control. The key advantages of our B-spline approach include:

\begin{itemize}
    \item \textbf{C2 Continuity}: Ensures smooth acceleration profiles without sudden jerks
    \item \textbf{Local Control}: Modifications to waypoints only affect nearby curve segments
    \item \textbf{Arc-Length Parameterization}: Enables consistent velocity control along the curve
    \item \textbf{Computational Efficiency}: Real-time trajectory generation suitable for dynamic environments
\end{itemize}

\section{Mathematical Foundation}

\subsection{B-Spline Curves}

A B-spline curve of degree $p$ is defined as:

\begin{equation}
\mathbf{C}(u) = \sum_{i=0}^{n} N_{i,p}(u) \mathbf{P}_i
\end{equation}

where:
\begin{itemize}
    \item $\mathbf{P}_i$ are the control points (derived from RRT* waypoints)
    \item $N_{i,p}(u)$ are the B-spline basis functions of degree $p$
    \item $u \in [u_p, u_{n+1}]$ is the parameter
    \item $n+1$ is the number of control points
\end{itemize}

\subsection{B-Spline Basis Functions}

The B-spline basis functions are defined recursively using the Cox-de Boor formula:

\begin{equation}
N_{i,0}(u) = \begin{cases}
1 & \text{if } u_i \leq u < u_{i+1} \\
0 & \text{otherwise}
\end{cases}
\end{equation}

\begin{equation}
N_{i,p}(u) = \frac{u - u_i}{u_{i+p} - u_i} N_{i,p-1}(u) + \frac{u_{i+p+1} - u}{u_{i+p+1} - u_{i+1}} N_{i+1,p-1}(u)
\end{equation}

where $\{u_i\}$ is the knot vector.

\subsection{Knot Vector Generation}

For a B-spline of degree $p$ with $n+1$ control points, we need $m+1$ knots where $m = n + p + 1$. We use a clamped uniform knot vector:

\begin{equation}
u_i = \begin{cases}
0 & \text{if } i < p+1 \\
\frac{i-p}{n-p+1} & \text{if } p+1 \leq i \leq n \\
1 & \text{if } i > n
\end{cases}
\end{equation}

This ensures the curve passes through the first and last control points.

\section{Control Point Generation from RRT* Waypoints}

\subsection{Waypoint Preprocessing}

Given RRT* waypoints $\{\mathbf{W}_0, \mathbf{W}_1, ..., \mathbf{W}_k\}$, we first preprocess them to ensure suitable spacing:

\begin{algorithm}
\caption{Waypoint Preprocessing}
\begin{algorithmic}
\STATE \textbf{Input:} Raw waypoints $\{\mathbf{W}_i\}$, minimum distance $d_{min}$, maximum distance $d_{max}$
\STATE \textbf{Output:} Processed waypoints $\{\mathbf{W}'_i\}$
\STATE $\mathbf{W}'_0 \leftarrow \mathbf{W}_0$
\FOR{$i = 1$ to $k$}
    \STATE $d \leftarrow \|\mathbf{W}_i - \mathbf{W}'_{last}\|$
    \IF{$d > d_{min}$}
        \IF{$d > d_{max}$}
            \STATE Insert intermediate points
        \ENDIF
        \STATE Add $\mathbf{W}_i$ to processed waypoints
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Control Point Computation}

For a cubic B-spline ($p = 3$), we generate control points using Catmull-Rom interpolation:

\begin{equation}
\mathbf{P}_i = \mathbf{W}_i + \alpha \cdot (\mathbf{T}_{i+1} - \mathbf{T}_{i-1})
\end{equation}

where $\mathbf{T}_i$ is the tangent at waypoint $i$ and $\alpha$ is a tension parameter.

For interior waypoints, the tangent is computed as:

\begin{equation}
\mathbf{T}_i = \frac{1}{2} \left( \frac{\mathbf{W}_{i+1} - \mathbf{W}_i}{\|\mathbf{W}_{i+1} - \mathbf{W}_i\|} + \frac{\mathbf{W}_i - \mathbf{W}_{i-1}}{\|\mathbf{W}_i - \mathbf{W}_{i-1}\|} \right)
\end{equation}

\section{Arc-Length Parameterization}

To achieve constant velocity along the curve, we reparameterize by arc length.

\subsection{Arc Length Computation}

The arc length from $u_a$ to $u_b$ is:

\begin{equation}
s(u_a, u_b) = \int_{u_a}^{u_b} \|\mathbf{C}'(u)\| du
\end{equation}

We approximate this using numerical integration (Simpson's rule):

\begin{equation}
s \approx \sum_{i=0}^{n-1} \frac{h}{6} \left[ \|\mathbf{C}'(u_i)\| + 4\|\mathbf{C}'(u_{i+0.5})\| + \|\mathbf{C}'(u_{i+1})\| \right]
\end{equation}

\subsection{Building the Arc-Length Table}

We construct a lookup table mapping arc length to parameter values:

\begin{lstlisting}[language=C++, caption=Arc-Length Table Construction]
void BuildArcLengthTable() {
    arc_length_table.clear();
    arc_length_table.push_back({0.0, 0.0});
    
    double total_length = 0.0;
    const int num_samples = 1000;
    
    for (int i = 1; i <= num_samples; ++i) {
        double u = static_cast<double>(i) / num_samples;
        double segment_length = ComputeSegmentLength(
            (i-1.0)/num_samples, u);
        total_length += segment_length;
        arc_length_table.push_back({u, total_length});
    }
}
\end{lstlisting}

\section{Velocity Profile Generation}

\subsection{Trapezoidal Velocity Profile}

We use a trapezoidal velocity profile to ensure smooth acceleration and deceleration:

\begin{equation}
v(t) = \begin{cases}
a_{max} \cdot t & \text{if } t < t_1 \text{ (acceleration)} \\
v_{max} & \text{if } t_1 \leq t < t_2 \text{ (cruise)} \\
v_{max} - a_{max}(t - t_2) & \text{if } t_2 \leq t < t_3 \text{ (deceleration)}
\end{cases}
\end{equation}

where:
\begin{itemize}
    \item $t_1 = \min\left(\frac{v_{max}}{a_{max}}, \frac{T}{2}\right)$ is the acceleration time
    \item $t_2 = T - t_1$ is the start of deceleration
    \item $t_3 = T$ is the total trajectory time
\end{itemize}

\subsection{Position Along Arc Length}

The position along the arc length at time $t$ is:

\begin{equation}
s(t) = \begin{cases}
\frac{1}{2}a_{max}t^2 & \text{if } t < t_1 \\
v_{max}(t - \frac{t_1}{2}) & \text{if } t_1 \leq t < t_2 \\
s_{total} - \frac{1}{2}a_{max}(T-t)^2 & \text{if } t_2 \leq t < T
\end{cases}
\end{equation}

\section{Trajectory Evaluation}

\subsection{Position Computation}

Given time $t$, we compute the robot position:

\begin{algorithm}
\caption{Position Evaluation}
\begin{algorithmic}
\STATE \textbf{Input:} Time $t$
\STATE \textbf{Output:} Position $\mathbf{p}(t)$, orientation $\theta(t)$
\STATE $s \leftarrow$ ComputeArcLength($t$) using velocity profile
\STATE $u \leftarrow$ GetParameterFromArcLength($s$) using lookup table
\STATE $\mathbf{p}(t) \leftarrow$ EvaluateBSpline($u$)
\STATE $\mathbf{v} \leftarrow$ EvaluateBSplineDerivative($u$)
\STATE $\theta(t) \leftarrow$ atan2($v_y$, $v_x$)
\end{algorithmic}
\end{algorithm}

\subsection{Velocity Computation}

The velocity in world frame is:

\begin{equation}
\mathbf{v}_{world} = \frac{ds}{dt} \cdot \frac{d\mathbf{C}}{ds} = v(t) \cdot \frac{\mathbf{C}'(u)}{\|\mathbf{C}'(u)\|}
\end{equation}

The angular velocity is:

\begin{equation}
\omega = \frac{d\theta}{dt} = \frac{d\theta}{ds} \cdot \frac{ds}{dt}
\end{equation}

where:

\begin{equation}
\frac{d\theta}{ds} = \frac{\mathbf{C}'(u) \times \mathbf{C}''(u)}{\|\mathbf{C}'(u)\|^3}
\end{equation}

\section{Implementation Details}

\subsection{Class Structure}

The B-spline trajectory planner consists of two main classes:

\begin{lstlisting}[language=C++, caption=Main Class Structure]
class BSplineTrajectory {
private:
    // B-spline parameters
    int degree_ = 3;  // Cubic B-spline
    std::vector<Eigen::Vector3d> control_points_;
    std::vector<double> knot_vector_;
    
    // Arc-length parameterization
    std::vector<std::pair<double, double>> arc_length_table_;
    double total_arc_length_;
    
    // Velocity profile
    double max_linear_velocity_ = 0.6;  // m/s
    double max_angular_velocity_ = 2.0; // rad/s
    double max_linear_acceleration_ = 0.5; // m/s^2
    
public:
    void SetPath(const std::vector<Eigen::Vector3d>& waypoints);
    std::pair<bool, Eigen::Vector3d> Update(
        const Eigen::Vector3d& current_pose);
};

class BSplineTrajectoryManager {
private:
    BSplineTrajectory trajectory_;
    rob::RobotManager* robot_manager_;
    
public:
    bool CreateTrajectoriesFromPath(
        const std::vector<Eigen::Vector3d>& path,
        double t_start_s);
    std::pair<bool, Eigen::Vector3d> Update(
        const Eigen::Vector3d& pose_fWorld);
};
\end{lstlisting}

\subsection{Numerical Stability}

To ensure numerical stability in the Cox-de Boor recursion:

\begin{lstlisting}[language=C++, caption=Stable Basis Function Evaluation]
double BSplineBasis(int i, int p, double u) {
    if (p == 0) {
        return (u >= knot_vector_[i] && 
                u < knot_vector_[i + 1]) ? 1.0 : 0.0;
    }
    
    double left = 0.0, right = 0.0;
    double denomLeft = knot_vector_[i + p] - knot_vector_[i];
    double denomRight = knot_vector_[i + p + 1] - 
                       knot_vector_[i + 1];
    
    if (denomLeft > 1e-10) {
        left = (u - knot_vector_[i]) / denomLeft * 
               BSplineBasis(i, p - 1, u);
    }
    
    if (denomRight > 1e-10) {
        right = (knot_vector_[i + p + 1] - u) / denomRight * 
                BSplineBasis(i + 1, p - 1, u);
    }
    
    return left + right;
}
\end{lstlisting}

\section{Performance Analysis}

\subsection{Computational Complexity}

\begin{itemize}
    \item \textbf{Preprocessing}: $O(n)$ where $n$ is the number of waypoints
    \item \textbf{B-spline evaluation}: $O(p^2)$ where $p$ is the degree (constant for cubic)
    \item \textbf{Arc-length table construction}: $O(m)$ where $m$ is the number of samples
    \item \textbf{Runtime evaluation}: $O(\log m)$ for binary search in arc-length table
\end{itemize}

\subsection{Memory Requirements}

\begin{itemize}
    \item Control points: $O(n)$ storage
    \item Knot vector: $O(n)$ storage
    \item Arc-length table: $O(m)$ storage
    \item Total: $O(n + m)$ where typically $m \gg n$
\end{itemize}

\section{Results and Validation}

\subsection{Smoothness Metrics}

The B-spline trajectory achieves:

\begin{itemize}
    \item \textbf{C2 continuity}: Acceleration is continuous throughout
    \item \textbf{Maximum jerk}: Bounded by the third derivative of the B-spline
    \item \textbf{Path deviation}: Maximum deviation from waypoints < 0.1m
\end{itemize}

\subsection{Comparison with Other Methods}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Method} & \textbf{Continuity} & \textbf{Computation} & \textbf{Smoothness} & \textbf{Path Following} \\
\hline
Linear & C0 & O(1) & Poor & Exact \\
Pure Pursuit & C1 & O(1) & Fair & Approximate \\
Hermite Spline & C1 & O(n) & Good & Exact at waypoints \\
B-Spline & C2 & O(n) & Excellent & Approximate \\
\hline
\end{tabular}
\caption{Comparison of trajectory planning methods}
\end{table}

\section{Practical Considerations}

\subsection{Parameter Tuning}

Key parameters for tuning the trajectory behavior:

\begin{itemize}
    \item \textbf{B-spline degree}: Higher degrees provide smoother curves but less local control
    \item \textbf{Knot spacing}: Affects how closely the curve follows waypoints
    \item \textbf{Velocity limits}: Trade-off between speed and smoothness
    \item \textbf{Acceleration limits}: Affects trajectory duration and jerk
\end{itemize}

\subsection{Real-time Constraints}

For SSL robots operating at 60Hz control frequency:

\begin{itemize}
    \item Trajectory evaluation must complete in < 16ms
    \item Arc-length table provides O(log n) lookup time
    \item Precomputation amortizes expensive operations
\end{itemize}

\section{Conclusion}

The B-spline trajectory planner successfully transforms discrete RRT* waypoints into smooth, dynamically feasible trajectories for omnidirectional robots. The implementation achieves:

\begin{enumerate}
    \item Smooth C2 continuous motion without velocity discontinuities
    \item Consistent velocity control through arc-length parameterization
    \item Real-time performance suitable for dynamic soccer environments
    \item Flexible framework extensible to higher-dimensional planning
\end{enumerate}

The planner has been successfully integrated into the SSL robot control system and demonstrates significant improvements in motion quality compared to traditional waypoint-following methods.

\section{Future Work}

Potential improvements and extensions include:

\begin{itemize}
    \item \textbf{Dynamic obstacle avoidance}: Real-time trajectory modification
    \item \textbf{Multi-robot coordination}: Synchronized trajectory planning
    \item \textbf{Optimal control integration}: Minimize energy or time
    \item \textbf{Learning-based parameter adaptation}: Automatic tuning based on performance metrics
\end{itemize}

\appendix

\section{Mathematical Derivations}

\subsection{B-Spline Derivatives}

The first derivative of a B-spline curve is:

\begin{equation}
\mathbf{C}'(u) = \sum_{i=0}^{n-1} \frac{p}{u_{i+p+1} - u_{i+1}} (\mathbf{P}_{i+1} - \mathbf{P}_i) N_{i,p-1}(u)
\end{equation}

The second derivative is:

\begin{equation}
\mathbf{C}''(u) = \sum_{i=0}^{n-2} \frac{p(p-1)}{(u_{i+p+1} - u_{i+1})(u_{i+p+2} - u_{i+2})} \Delta^2 \mathbf{P}_i N_{i,p-2}(u)
\end{equation}

where $\Delta^2 \mathbf{P}_i = \mathbf{P}_{i+2} - 2\mathbf{P}_{i+1} + \mathbf{P}_i$.

\subsection{Curvature Computation}

The curvature $\kappa$ at parameter $u$ is:

\begin{equation}
\kappa(u) = \frac{\|\mathbf{C}'(u) \times \mathbf{C}''(u)\|}{\|\mathbf{C}'(u)\|^3}
\end{equation}

This is used to compute angular velocity requirements.

\section{Implementation Code Snippets}

\subsection{B-Spline Evaluation}

\begin{lstlisting}[language=C++, caption=Complete B-Spline Evaluation]
Eigen::Vector3d EvaluateBSpline(double u) {
    Eigen::Vector3d result = Eigen::Vector3d::Zero();
    
    // Find the knot span
    int span = FindKnotSpan(u);
    
    // Compute basis functions
    std::vector<double> basis(degree_ + 1);
    ComputeBasisFunctions(span, u, basis);
    
    // Sum contributions
    for (int i = 0; i <= degree_; ++i) {
        int idx = span - degree_ + i;
        if (idx >= 0 && idx < control_points_.size()) {
            result += basis[i] * control_points_[idx];
        }
    }
    
    return result;
}
\end{lstlisting}

\subsection{Velocity Profile Implementation}

\begin{lstlisting}[language=C++, caption=Trapezoidal Velocity Profile]
double ComputeVelocityProfile(double t, double total_time) {
    double accel_time = std::min(
        max_linear_velocity_ / max_linear_acceleration_,
        total_time / 2.0
    );
    
    if (t < accel_time) {
        // Acceleration phase
        return max_linear_acceleration_ * t;
    } else if (t < total_time - accel_time) {
        // Cruise phase
        return max_linear_velocity_;
    } else {
        // Deceleration phase
        return max_linear_acceleration_ * (total_time - t);
    }
}
\end{lstlisting}

\end{document}