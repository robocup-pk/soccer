\documentclass{article}\usepackage[utf8]{inputenc}\usepackage{amsmath}\usepackage{amssymb}\usepackage{geometry}\geometry{a4paper, margin=1in}\title{RoboCup SSL Ball Interaction Models}\author{Gemini CLI Agent}\date{July 24, 2025}\begin{document}\maketitle\section{Introduction}This document outlines the mathematical models and implementation details for ball interaction, specifically kicking and dribbling, within the RoboCup Small Size League (SSL) simulation environment. These models are designed to simulate realistic ball physics and robot-ball interactions under SSL constraints.\section{Kick Model}The kick model is primarily implemented through the \texttt{kin::Kick} function and the \texttt{state::Ball::ApplyKick} method.\subsection{The \texttt{kin::Kick} Function}The \texttt{kin::Kick} function serves as the entry point for a robot to attempt a kick. It enforces several SSL-specific constraints before applying the kick force to the ball.\subsubsection{Input Parameters}\begin{itemize}    \item \texttt{state::SoccerObject\& robot}: The robot attempting the kick.    \item \texttt{state::SoccerObject\& ball}: The ball to be kicked.    \item \texttt{double kick\_power}: Desired kick power in meters per second (m/s), with a default of 3.0 m/s.    \item \texttt{bool force\_kick}: If \texttt{true}, bypasses orientation and distance checks (used for debugging/testing).\end{itemize}\subsubsection{Constraints and Checks}\begin{itemize}    \item \textbf{Distance Check}: The ball must be within a maximum kicking distance from the robot's center.    \begin{equation*}        \text{distance} = \sqrt{(ball_x - robot_x)^2 + (ball_y - robot_y)^2}    \end{equation*}    If \texttt{distance > ssl::MAX\_KICK\_DISTANCE} (0.25m), the kick fails unless \texttt{force\_kick} is true.    \item \textbf{Front Sector Check}: The ball must be within the robot's front kicking sector. This is determined by the \texttt{robot.IsPointInFrontSector(ball\_point)} method.    \begin{itemize}        \item The robot's orientation is given by \texttt{robot.position[2]} (angle in radians).        \item A \texttt{front\_dir} vector is calculated:        \begin{equation*}            \text{front\_dir} = (\cos(\text{robot\_angle}), \sin(\text{robot\_angle}))        \end{equation*}        \item The dot product between the normalized vector from robot to ball (\texttt{to\_point.normalized()}) and \texttt{front\_dir} must exceed a certain threshold (\texttt{cos(M\_PI / 4.0f)} for a 90-degree front sector).    \end{itemize}    If the ball is not in the front sector, the kick fails unless \texttt{force\_kick} is true.    \item \textbf{Power Regulation}: The requested \texttt{kick\_power} is capped at \texttt{ssl::MAX\_KICK\_POWER} (6.0 m/s).    \begin{equation*}        \text{actual\_kick\_power} = \min(\text{kick\_power}, \text{ssl::MAX\_KICK\_POWER})    \end{equation*}\end{itemize}\subsubsection{Kick Application}If all constraints are met (or bypassed by \texttt{force\_kick}), the kick is applied by calling \texttt{kin::ApplyKickToBall}. The \texttt{kick\_direction} is determined by the robot's current orientation:\begin{equation*}    \text{kick\_direction} = (\cos(\text{robot.position[2]}), \sin(\text{robot.position[2]}))\end{equation*}\subsection{The \texttt{state::Ball::ApplyKick} Method}This method is responsible for directly modifying the ball's velocity and spin based on the kick.\subsubsection{Velocity Update}The ball's velocity is updated in the 2D plane according to the normalized kick direction and the actual kick power:\begin{align*}    \text{velocity}_x \&= \text{normalized\_direction}_x \times \text{kick\_power} \\    \text{velocity}_y \&= \text{normalized\_direction}_y \times \text{kick\_power} \\    \text{velocity}_z \&= 0.0 \quad (\text{Always 2D for SSL})\end{align*}\subsubsection{Spin Addition}A minimal, random spin is added to the ball to simulate realistic kick effects:\begin{equation*}    \text{spin}_z = \text{kick\_power} \times 0.1 \times (0.5 - \text{random\_value})\end{equation*}where \texttt{random\_value} is between 0 and 1.\section{Dribble Model}The dribble model is implemented in the \texttt{state::Ball::ApplyDribbleForce} method. This method applies a continuous force to the ball to simulate dribbling.\subsection{The \texttt{state::Ball::ApplyDribbleForce} Method}\subsubsection{Velocity Update}The ball's velocity is adjusted by the \texttt{dribble\_force} vector. A scaling factor (0.2) is applied to the force to provide better control:\begin{align*}    \text{velocity}_x \&+= \text{dribble\_force}_x \times 0.2 \\    \text{velocity}_y \&+= \text{dribble\_force}_y \times 0.2\end{align*}\subsubsection{Speed Limiting}The ball's speed during dribbling is limited to a maximum value (\texttt{max\_dribble\_speed}, typically 3.0 m/s) to ensure realistic dribbling behavior:\begin{align*}    \text{current\_speed} \&= \sqrt{\text{velocity}_x^2 + \text{velocity}_y^2} \\    \text{if (current\_speed} \&> \text{max\_dribble\_speed}) \\    \text{velocity}_x \&= (\text{velocity}_x / \text{current\_speed}) \times \text{max\_dribble\_speed} \\    \text{velocity}_y \&= (\text{velocity}_y / \text{current\_speed}) \times \text{max\_dribble\_speed}\end{align*}\end{document}